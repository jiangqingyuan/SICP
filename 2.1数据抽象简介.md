# 2.1 数据抽象简介（Introduction to Data Abstraction)

数据抽象的基本思想是，使用复合数据对象，以便它们操作抽象数据，不关心对象的具体表示。

数据的具体表示和使用，这两个部分之间的接口将是一组过程，称为选择器（selectors) 和构造器(constructors)，它们根据具体表示来实现抽象数据。

选择就是extract。

基础操作->封装成seletor和constructor->基础操作->封装成seletor和constructor。。。。

这个简单的想法有很多优点。 一个好处是程序更易于维护和修改。

任何复杂数据结构可以用编程语言提供的基础数据结构以多种方式表示。当然，表示法的选择会影响对其进行操作的程序; 因此，如果表示要在以后某个时间改变，则可能必须相应地修改所有这样的程序。

在大型程序的情况下，这个任务可能是**耗时和昂贵**的，除非通过设计将对表示的依赖性限制到非常少的程序模块。

我们在这里使用的是一种强有力的综合策略：wishful thinking。我们还没有说明有理数是如何表示的，也没有说明numer、denom和make-rat过程应该如何实现。即便如此，如果我们确实有这三个过程，那么我们就可以用下面的关系进行加、减、乘、除和相等性检验。

封装可以推迟决策。使得使用封装实现基础操作不用考虑很多细节。

假设我们正在设计一个有理数包，并且我们最初不能决定是在构造时还是在选择时执行gcd。**数据抽象方法为我们提供了一种推迟决策的方法，而不会系统的其余部分取得进展的能力。**

为了使我们能够实现数据抽象的具体层次，我们的语言提供了一个称为pair的复合结构，它可以用原始过程cons来构造。

```lisp
(define x (cons 1 2))
```

一般来说，我们可以认为数据，由一些选择器和构造器的集合，以及这些过程为成为有效的表示而必须满足的指定条件，定义的。

用带值的过程来实现pair，牛啊。

将过程作为对象进行操作的能力自动提供了表示复合数据的能力。

现在这可能看起来很奇怪，但是数据的过程化表示将在我们的编程库（repertoire）中扮演中心角色。这种编程风格通常被称为消息传递（message passing）。

The name cons stands for 'construct'. The names car and cdr derive from the original implementation of Lisp on the IBM 704. That machine had an addressing scheme that allowed one to reference the address and ''decrement'' parts of a memory location. Car stands for Contents of Address part of Register'' and cdr (pronounced could-er) stands for ''Contents of Decrement part of Register.''

```lisp
(define make-rat cons)
(define numer car)
(define denom cdr)
```

这个写法 不是make-rat调用cons，而是make-rat就是cons，所以调用make-rat时只调用了一个过程，而不是两个。另一方面，这样做会破坏debug：您可能想观看 make-rat 被调用，但您肯定不想观看对cons的每次调用。
