# 1 使用过程构造抽象（Building Abstractions with Procedures）

> Procedure，翻译为过程，对应其他语言的function或method。
>
> 区分[子程序、子例程、过程、函数、方法 的异同_imjqy的博客-CSDN博客](https://blog.csdn.net/qq_42195302/article/details/128737346)
>
> 看完这一页，至少应该知道process和procedure的区别。
>
> 开篇引言，引用了一篇关于人类理解的文章。大致意思是，mind对简单的ideas施加power的acts主要是三种，组合ideas，并列ideas，拆分ideas，这样都能得到ideas。

约翰·洛克，一篇关于人类理解的文章（1960）

mind对简单的ideas施加power的acts主要有以下三点：

1.把几个简单ideas组合成一个复合的idea，从而形成所有复杂的ideas。

2.第二种是两种ideas结合在一起，无论简单复杂，并把它们放在一起，以便一次看到它们，而不是把它们合为一种，由此得到[ideas of relations](https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A7%82%E5%BF%B5/22645025?fr=aladdin)。

> 关系的观念（ ideas of relations）英国洛克用语。复杂观念的一种。
>
> 人心把一个观念和其他观念并列起来加以考虑和互相比较所形成的观念。如父与子、夫与妻、大与小、因与果等。

3.第三种是把ideas与伴随着它们实际存在的所有其他ideas分开：这叫做抽象，因此产生了所有的general ideas。

> general ideas在不同语境的句子中有不同的翻译，比方说：大体的想法，笼统的想法, 总体的想法，概述，一般的想法，普遍的想法，普通的想法等等。

我们将要研究*computational process*。

> Computational means using computers. process在操作系统的中文书中翻译为进程，使用计算机的进程，姑且简写为计算进程。

计算进程是驻留在计算机中的抽象存在，随着进程evolve，进程会操作称为*数据*的其他抽象事物。进程的evolution由称为*程序*的规则模式指导。 人们创建程序来指挥进程。 实际上，我们用我们的咒语召唤了计算机的灵魂。

计算进程确实很像巫师对灵魂的idea。 它看不见也摸不着。 它根本不是由物质组成的。然而，这是非常真实的。 它可以执行智力工作。 它可以回答问题。 它可以通过在银行花钱或在工厂控制机械臂来影响世界。 我们用来召唤进程的程序就像巫师的咒语。 它们由神秘而深奥的*编程语言*中的**符号表达式**（ symbolic expressions）精心组合而成，这些语言规定了我们希望进程执行的任务。

> 看到这里应该知道process和program的关系。

在一台正常工作的计算机中，计算进程精确而准确（precisely and accurately）地执行程序。 因此，就像巫师的学徒一样，新手程序员必须学会理解和预测他们施法的后果。 即使是程序中的小错误（通常称为*bugs*或*glitches*）也会产生复杂且无法预料的后果。

幸运的是，学习编程比学习巫术危险要小得多，因为我们打交道的灵魂很方便地以安全的方式约束着。 然而，现实世界的编程需要细心、专业知识和智慧。 例如，计算机辅助设计程序中的一个小错误可能导致飞机或水坝的灾难性倒塌或工业机器人的自我毁灭。

高级软件工程师有能力组织程序，以便他们可以合理地确定所产生的进程将执行预期的任务。 他们可以提前看到系统的行为。 他们知道如何构建程序，使未预料到的问题不会导致灾难性后果，并且当问题确实出现时，他们可以*debug*他们的程序。 设计良好的计算系统，如设计良好的汽车或核反应堆，是以模块化方式设计的，

## 用Lisp编程

我们需要一种适当的语言来描述进程，为此，我们将使用编程语言Lisp。

> Lisp是第一个程序完全由表达式组成，procedure也是有返回值的表达式，支持条件结构（if-then-else），支持递归，支持垃圾回收机制的语言。
>
> 因为过程也是表达式，有返回值，所以过程可以参与构成新的表达式，这为描述数学运算提供了极大遍历。
>
> 支持条件结构，可以更好地描述分段函数。
>
> 支持递归，可以实现递归运算。

正如我们的日常思维通常是用自然语言(如英语、法语或日语)表达的，定量现象的描述是用数学符号来表达的，我们的程序性思维也将用LISP语言来表达。

Lisp 是在 20 世纪 50 年代后期发明的，是为了推理某些类型的逻辑表达式(称为*递归方程（drecursion equations）*, 递归方程是一个计算模型model for computation），一种formalism（一种表示信息的符号及其结构）。 该语言由 John McCarthy 构想，基于他的论文“Recursive Functions ofSymbolic Expressions and Their Computation by Machine”（符号表达式的递归函数及其使用机器计算）(McCathy 1960)。

尽管 Lisp 最初是一种数学形式的formalism，但它是一种实用的编程语言。 Lisp *解释器（interpreter）*是一种执行 Lisp 语言描述的进程的机器。第一个 Lisp 解释器是由麦卡锡在麻省理工学院电子研究实验室人工智能小组和麻省理工学院计算中心的同事和学生的帮助下实现的。[^1]

Lisp，其名称是 LISt Processing 的首字母缩写，其设计目的是提供符号处理功能，以解决诸如代数表达式的符号微分和积分等编程问题。为此目的，它包括了被称为原子(atoms)和列表(lists)的新数据对象，这是它与那个时期所有其他语言最引人注目的区别。

Lisp 不是协同设计的产物。相反，它以一种实验性的方式非正式地发展，以响应用户的需求和务实的实施考虑。多年来，Lisp的非正式演变一直在继续，并且Lisp 用户社区历来抵制公布该语言的任何“官方”定义的尝试。

这种演变，再加上初始概念的灵活性和优雅性，使 Lisp 这一当今广泛使用的第二古老的语言（仅 Fortran 更古老）能够不断改编，以包含最现代的程序设计思想。

因此，到目前为止，Lisp 是一个方言家族，虽然共享大部分原始特征，但可能在重要方面彼此不同。 本书中使用的 Lisp 方言称为 Scheme。[^2]

由于其实验性质和对符号操作的强调，Lisp 起初在数值计算方面效率非常低，至少与 Fortran 相比是这样。然而，多年来，Lisp 编译器已经开发出来，可以将程序翻译成机器代码，从而可以相当有效地执行数值计算。而对于特殊的应用，Lisp 的使用效果非常好。[^3]

尽管 Lisp 还没有克服其无可救药的低效率的旧名声，但 Lisp 现在已用于许多效率不是主要关注点的应用程序中。例如，Lisp 已成为操作系统 shell 语言以及编辑器和计算机辅助设计系统的扩展语言的首选语言。

> 编辑器说的是Emacs，编写插件用emacs Lisp。

如果 Lisp 不是主流语言，我们为什么要用它作为我们讨论编程的框架？ 因为该语言具有独特的特性，使其成为研究重要的编程结构（constructs）和数据结构（structures）并将它们与支持它们的语言特性相关联的绝佳媒介。 这些特性中最重要的是 Lisp 对进程的描述，称为*过程（procedure）*，过程本身可以作为 Lisp data来表示和操作。这一点的重要性在于，有强大的程序设计技术依赖于模糊“被动”数据和“主动”进程之间的传统区别的能力。

> 传统区别指的是，把进程和数据区分成两个抽象事物，进程操作数据。
>
> 进程的evolution由称为*程序*的规则模式指导。
>
> 在使用Lisp编写的程序中，过程是Lisp对进程的描述。Lisp data是Lisp对数据的描述。
>
> 在程序这个规则模式中，过程本身可以作为Lisp data，这模糊了进程和数据之间的区别。
>
> 依赖这个能力的程序设计技术有很多。
>
> 比如，有返回值的函数可以像一个变量一样，参与构成表达式。
>
> 再比如C语言中，可以使用函数指针来调用函数，函数指针可以当作函数的参数，相当于把函数当成参数，从而在函数内部调用不同的函数，这是实现面向对象的多态的关键技术。

正如我们将发现的，Lisp 在将过程作为数据处理方面的灵活性使其成为探索这些技术的最方便的语言之一。将过程表示为数据的能力也使 Lisp 成为编写必须将其他程序作为数据来操作的程序的优秀语言，例如支持计算机语言的解释器和编译器。 除了这些考虑之外，使用 Lisp 编程非常有趣。

[^1]: Lisp 1 程序员手册于 1960 年问世，Lisp 1.5 程序员手册（McCarthy 1965）于 1962 年出版。McCarthy 1978 描述了 Lisp 的早期历史。

[^2]: 20世纪70年代大多数主要的Lisp程序都是用两种方言编写的，一种是由麻省理工学院MAC项目开发的MacLisp(Moon 1978；Pitman 1983)，另一种是由Bolt Beranek and Newman Inc.和Xerox Palo Alto研究中心开发的Interlisp(Teitelman 1974)。便携式标准 Lisp（Hearn 1969；Griss 1981）是一种 Lisp 方言，旨在在不同机器之间轻松移植。 MacLisp催生了许多子方言，例如由加州大学伯克利分校开发的Franz Lisp和Zetalisp(Moon 1981)，Zetalisp基于麻省理工学院人工智能实验室设计的专用处理器，可以非常高效地运行Lisp。本书中使用的 Lisp 方言称为 Scheme（Steele 1975），由 MIT 人工智能实验室的 Guy Lewis Steele Jr. 和 Gerald Jay Sussman 于 1975 年发明，后来在 MIT 重新实现用于教学。Scheme 于 1990 年成为 IEEE 标准 (IEEE 1990)。 Common Lisp 方言（Steele 1982，Steele 1990）是由 Lisp 社区开发的，它结合了早期 Lisp 方言的特征，为 Lisp 制定了一个工业标准。 Common Lisp 于 1994 年成为 ANSI 标准 (ANSI 1994)。

[^3]: 其中一项特殊应用是具有重大科学意义的突破性计算——对太阳系运动的积分，将先前的结果扩展了近两个数量级，并证明了太阳系的动力学是混沌的。 这种计算是通过新的集成算法、专用编译器和专用计算机实现的，所有这些都是在用 Lisp 编写的软件工具的帮助下实现的（Abelson 等人 1992 年；Sussman 和 Wisdom 1992 年）。
